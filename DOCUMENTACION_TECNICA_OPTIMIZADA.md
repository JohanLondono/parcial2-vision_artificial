# Sistema de Detecci√≥n de Objetos en Tr√°fico Vehicular
## Documentaci√≥n T√©cnica - Enfoque en Extracci√≥n de Caracter√≠sticas

**Universidad del Quind√≠o - Visi√≥n Artificial**  
**Fecha:** Octubre 2025  
**Versi√≥n:** 5.0 - Edici√≥n Optimizada y Enfocada

---

## Tabla de Contenidos

1. [Introducci√≥n](#1-introducci√≥n)
2. [Arquitectura del Sistema](#2-arquitectura-del-sistema)
3. [Fundamentos Matem√°ticos B√°sicos](#3-fundamentos-matem√°ticos-b√°sicos)
4. [Preprocesamiento (Resumen)](#4-preprocesamiento-resumen)
5. [Extracci√≥n de Caracter√≠sticas - Descriptores Cl√°sicos](#5-extracci√≥n-de-caracter√≠sticas---descriptores-cl√°sicos)
6. [Extracci√≥n de Caracter√≠sticas - Algoritmos Avanzados](#6-extracci√≥n-de-caracter√≠sticas---algoritmos-avanzados)
7. [An√°lisis de Texturas](#7-an√°lisis-de-texturas)
8. [Detecci√≥n de Objetos Espec√≠ficos](#8-detecci√≥n-de-objetos-espec√≠ficos)
9. [Evaluaci√≥n y Comparaci√≥n](#9-evaluaci√≥n-y-comparaci√≥n)
10. [Referencias](#10-referencias)

---

## 1. Introducci√≥n

### 1.1 Objetivos del Sistema

Sistema especializado en **extracci√≥n de caracter√≠sticas visuales** para an√°lisis de tr√°fico vehicular, implementando:

- ‚úÖ **Descriptores Cl√°sicos:** HOG, SIFT, SURF, ORB, KAZE, AKAZE
- ‚úÖ **Descriptores Avanzados:** FREAK (bio-inspirado)
- ‚úÖ **An√°lisis de Texturas:** GLCM, LBP
- ‚úÖ **An√°lisis de Movimiento:** Optical Flow (Lucas-Kanade, Farneback)
- ‚úÖ **Segmentaci√≥n Avanzada:** GrabCut con modelos GMM
- ‚úÖ **Detecci√≥n de Formas:** Transformada de Hough, LoG

### 1.2 Enfoque Principal

Este documento se centra en:
1. **Fundamentos matem√°ticos** de cada algoritmo de extracci√≥n
2. **Comparaci√≥n rigurosa** entre m√©todos
3. **Aplicaciones espec√≠ficas** en tr√°fico vehicular
4. **Ventajas y limitaciones** de cada t√©cnica

---

## 2. Arquitectura del Sistema

### 2.1 M√≥dulos de Extracci√≥n

```
Sistema de Extracci√≥n de Caracter√≠sticas
‚îÇ
‚îú‚îÄ‚îÄ modules/
‚îÇ   ‚îú‚îÄ‚îÄ hog_kaze.py                # HOG + KAZE
‚îÇ   ‚îú‚îÄ‚îÄ surf_orb.py                # SURF + ORB
‚îÇ   ‚îú‚îÄ‚îÄ advanced_algorithms.py     # AKAZE, FREAK, GrabCut, LoG
‚îÇ   ‚îú‚îÄ‚îÄ texture_analysis.py        # GLCM, LBP
‚îÇ   ‚îî‚îÄ‚îÄ comparison_metrics.py      # Evaluaci√≥n comparativa
‚îÇ
‚îî‚îÄ‚îÄ detectores/
    ‚îú‚îÄ‚îÄ detector_llantas.py        # Hough + Textura
    ‚îú‚îÄ‚îÄ detector_senales.py        # Color + Forma
    ‚îî‚îÄ‚îÄ detector_semaforos.py      # Estructura + Estado
```

### 2.2 Pipeline de Extracci√≥n

```
Imagen ‚Üí Preprocesamiento (m√≠nimo) ‚Üí Extracci√≥n Caracter√≠sticas ‚Üí An√°lisis ‚Üí Resultados
                                            ‚Üì
                        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                        ‚îÇ                                         ‚îÇ
                   Descriptores                              An√°lisis
                   Locales/Globales                         Temporal
```

---

## 3. Fundamentos Matem√°ticos B√°sicos

### 3.1 Convoluci√≥n y Gradientes

**Convoluci√≥n (base de todo filtro):**
$$
(I * K)(x, y) = \sum_i \sum_j I(x-i, y-j) \cdot K(i, j)
$$

**Gradientes (detecci√≥n de caracter√≠sticas):**
- **Magnitud:** $|G| = \sqrt{G_x^2 + G_y^2}$
- **Orientaci√≥n:** $\theta = \arctan(G_y/G_x)$

### 3.2 Espacio de Escala

**Gaussiano (lineal):**
$$
L(x, y, \sigma) = G(x, y, \sigma) * I(x, y)
$$

**No Lineal (KAZE/AKAZE):**
$$
\frac{\partial L}{\partial t} = \text{div}(c(x,y,t) \cdot \nabla L)
$$

Donde $c$ es funci√≥n de conductividad que preserva bordes.

---

## 4. Preprocesamiento (Resumen)

### 4.1 Operaciones Esenciales

| Operaci√≥n | Prop√≥sito | Complejidad |
|-----------|-----------|-------------|
| **Filtro Gaussiano** | Reducci√≥n de ruido | $O(n^2)$ |
| **Normalizaci√≥n** | Invarianza a iluminaci√≥n | $O(n)$ |
| **Redimensionamiento** | Uniformidad de escala | $O(n)$ |
| **Conversi√≥n Grises** | Reducci√≥n dimensionalidad | $O(n)$ |

### 4.2 Filtros Aplicados

- **Suavizado:** Gaussiano con $\sigma = 1.0-2.0$
- **Realce de bordes:** Sobel, Canny
- **Morfolog√≠a:** Apertura/cierre para ruido

**Nota:** El preprocesamiento es m√≠nimo para preservar informaci√≥n de caracter√≠sticas.

---

## 5. Extracci√≥n de Caracter√≠sticas - Descriptores Cl√°sicos

### 5.1 HOG (Histogram of Oriented Gradients)

#### Fundamento Matem√°tico

HOG captura la distribuci√≥n de gradientes orientados en regiones locales.

**Pipeline completo:**

1. **Normalizaci√≥n Gamma:**
   $$I'(x,y) = I(x,y)^\gamma, \quad \gamma \approx 0.5$$

2. **C√°lculo de Gradientes:**
   $$G_x = I * [-1, 0, +1], \quad G_y = I * [-1, 0, +1]^T$$
   $$|G| = \sqrt{G_x^2 + G_y^2}, \quad \theta = \arctan(G_y/G_x)$$

3. **Histogramas por Celda:**
   - Celda: 8√ó8 p√≠xeles
   - 9 bins de orientaci√≥n (0¬∞-180¬∞)
   - Voto ponderado por magnitud

4. **Normalizaci√≥n por Bloques:**
   - Bloque: 2√ó2 celdas = 16√ó16 p√≠xeles
   - Normalizaci√≥n L2-Hys:
   $$v' = \frac{v}{||v||_2 + \epsilon}, \quad v'' = \min(v', 0.2), \quad v_{final} = \frac{v''}{||v''||_2 + \epsilon}$$

5. **Descriptor Final:**
   - Dimensi√≥n t√≠pica: 3780D para imagen 128√ó64
   - Concatenaci√≥n de todos los bloques

#### Caracter√≠sticas Clave

- **Tipo:** Descriptor denso (grid regular)
- **Invarianzas:** Escala parcial, iluminaci√≥n moderada
- **Dimensionalidad:** Alta (miles de valores)
- **Velocidad:** Moderada (m√°s lento que binarios)

#### Aplicaciones en Tr√°fico

- üöó **Detecci√≥n de veh√≠culos:** Template matching
- üö∂ **Detecci√≥n de peatones:** Clasificador SVM
- ü™ß **Clasificaci√≥n de se√±ales:** Forma + color

---

### 5.2 SIFT (Scale-Invariant Feature Transform)

#### Fundamento Matem√°tico

**Espacio de Escala Gaussiano:**
$$
L(x, y, \sigma) = G(x, y, \sigma) * I(x, y)
$$

**Difference of Gaussians (DoG):**
$$
D(x, y, \sigma) = L(x, y, k\sigma) - L(x, y, \sigma) \approx \sigma \nabla^2 G
$$

**Detecci√≥n de extremos:** Buscar m√°ximos/m√≠nimos en espacio 3D (x, y, œÉ)

**Construcci√≥n del Descriptor:**

1. **Regi√≥n 16√ó16 alrededor del keypoint**
2. **4√ó4 subregiones de 4√ó4 p√≠xeles**
3. **Histograma de 8 orientaciones por subregi√≥n**
4. **Descriptor final:** 4√ó4√ó8 = **128 dimensiones**

**Orientaci√≥n dominante:**
$$
\theta = \text{pico del histograma de orientaciones en ventana circular}
$$

#### Caracter√≠sticas Clave

- **Invarianzas:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (escala, rotaci√≥n, iluminaci√≥n, viewpoint parcial)
- **Precisi√≥n:** Muy alta
- **Velocidad:** Lenta
- **Memoria:** Media (128D flotante)
- **Patente:** Expirada (2020)

#### Ventajas vs Desventajas

**‚úÖ Ventajas:**
- Extremadamente robusto
- Gold standard para matching
- Excelente localizaci√≥n

**‚ùå Desventajas:**
- Computacionalmente costoso
- Descriptor flotante (no para matching binario)
- Muchos keypoints redundantes

---

### 5.3 SURF (Speeded-Up Robust Features)

#### Fundamento Matem√°tico

**Imagen Integral:** Acelera c√≥mputo de sumas en regiones rectangulares
$$
I_{\text{sum}}(x,y) = \sum_{i=0}^x \sum_{j=0}^y I(i,j)
$$

**Aproximaci√≥n de Laplaciano con Box Filters:**
$$
\det(H_{\text{approx}}) = D_{xx} D_{yy} - (0.9 D_{xy})^2
$$

Donde $D_{xx}$, $D_{yy}$, $D_{xy}$ son respuestas de filtros box.

**Descriptor:**

1. **Regi√≥n 20s√ó20s** (s = escala)
2. **4√ó4 subregiones**
3. **Por subregi√≥n:** $\sum dx, \sum dy, \sum |dx|, \sum |dy|$
4. **Descriptor final:** 4√ó4√ó4 = **64 dimensiones** (o 128 extendido)

#### Caracter√≠sticas Clave

- **Velocidad:** 3-4√ó m√°s r√°pido que SIFT
- **Precisi√≥n:** Comparable a SIFT
- **Descriptor:** M√°s compacto (64D vs 128D)
- **Invarianzas:** Escala, rotaci√≥n

#### Comparaci√≥n SURF vs SIFT

| Aspecto | SURF | SIFT |
|---------|------|------|
| **Velocidad** | ‚ö°‚ö°‚ö°‚ö° | ‚ö°‚ö° |
| **Precisi√≥n** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **Descriptor** | 64D/128D | 128D |
| **Implementaci√≥n** | Imagen integral | Pir√°mide DoG |
| **Patente** | S√≠ (restrictiva) | Expirada |

---

### 5.4 ORB (Oriented FAST and Rotated BRIEF)

#### Fundamento Matem√°tico

**Componente 1: FAST (Features from Accelerated Segment Test)**

Detector de esquinas ultra-r√°pido:
1. Considerar c√≠rculo de 16 p√≠xeles alrededor de punto $p$
2. Si $n$ p√≠xeles consecutivos son todos m√°s brillantes o m√°s oscuros que $I_p + t$
3. Entonces $p$ es esquina

**Componente 2: Orientaci√≥n con Momentos de Intensidad**
$$
\theta = \arctan2(m_{01}, m_{10})
$$

Donde $m_{pq} = \sum x^p y^q I(x,y)$ en vecindad del keypoint.

**Componente 3: BRIEF Rotado (rBRIEF)**

1. **Selecci√≥n de pares:** 256 pares $(x_i, y_i)$ predefinidos
2. **Test binario:**
   $$b_i = \begin{cases} 1 & \text{si } I(x_i) < I(y_i) \\ 0 & \text{en otro caso} \end{cases}$$
3. **Rotaci√≥n seg√∫n orientaci√≥n:** Rotar patr√≥n con matriz de rotaci√≥n $R_\theta$
4. **Descriptor final:** 256 bits = 32 bytes

**Matching con Distancia Hamming:**
$$
d_H(a, b) = \text{popcount}(a \oplus b)
$$

#### Caracter√≠sticas Clave

- **Velocidad:** ‚ö°‚ö°‚ö°‚ö°‚ö° (m√°s r√°pido de todos)
- **Descriptor:** Binario (32 bytes)
- **Matching:** Hardware-accelerated (XOR + popcount)
- **Licencia:** Libre (no patentado)
- **Invarianza:** Rotaci√≥n ‚úì, Escala ‚úó

#### Aplicaciones Ideales

- üì± **Dispositivos m√≥viles:** Recursos limitados
- üé• **Tiempo real:** Video tracking, SLAM
- ü§ñ **Rob√≥tica:** Navegaci√≥n, localizaci√≥n
- üîß **Prototipado r√°pido:** Desarrollo √°gil

---

### 5.5 KAZE y AKAZE

#### Fundamento Matem√°tico

**KAZE:** Difusi√≥n No Lineal en Espacio de Escala

**Ecuaci√≥n de Difusi√≥n:**
$$
\frac{\partial L}{\partial t} = \text{div}(c(x,y,t) \cdot \nabla L)
$$

**Funci√≥n de Conductividad (Perona-Malik G2):**
$$
c(x,y,t) = \frac{1}{1 + \left(\frac{|\nabla L_\sigma|}{K}\right)^2}
$$

**Efecto:**
- $|\nabla L| \ll K$: $c \approx 1$ ‚Üí difusi√≥n completa (regiones uniformes)
- $|\nabla L| \gg K$: $c \approx 0$ ‚Üí no difusi√≥n (bordes preservados)

**Ventaja sobre Gaussiano:**
- Gaussiano: Borra bordes junto con ruido
- KAZE: Preserva bordes mientras suaviza texturas

#### AKAZE: Aceleraci√≥n con FED

**Fast Explicit Diffusion (FED):**
- Esquema num√©rico m√°s eficiente
- 2-3√ó m√°s r√°pido que KAZE
- Convergencia similar

**Descriptor M-LDB (Modified Local Difference Binary):**

1. **Grid de muestreo** adaptativo por escala
2. **Comparaciones binarias** entre regiones
3. **Descriptor:** 486 bits (61 bytes)

#### Comparaci√≥n Completa

| Caracter√≠stica | KAZE | AKAZE | SIFT | SURF | ORB |
|----------------|------|-------|------|------|-----|
| **Espacio escala** | No lineal | No lineal (FED) | Gaussiano | Gaussiano | Pir√°mide |
| **Descriptor** | M-SURF (64D) | M-LDB (486b) | 128D | 64D | 256b |
| **Tipo** | Flotante | Binario | Flotante | Flotante | Binario |
| **Velocidad** | ‚ö°‚ö° | ‚ö°‚ö°‚ö° | ‚ö° | ‚ö°‚ö°‚ö° | ‚ö°‚ö°‚ö°‚ö° |
| **Precisi√≥n** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| **Memoria** | Alta | Media | Media | Media | Baja |
| **Patente** | No | No | No | S√≠ | No |

#### Aplicaciones en Tr√°fico

- üéØ **Matching robusto:** Im√°genes con bordes fuertes
- üåßÔ∏è **Condiciones adversas:** Lluvia, niebla (bordes preservados)
- üì∏ **Alta resoluci√≥n:** Detalles finos en se√±ales
- üîÑ **Multi-escala:** Veh√≠culos a diferentes distancias

---

## 6. Extracci√≥n de Caracter√≠sticas - Algoritmos Avanzados

### 6.1 FREAK (Fast Retina Keypoint)

#### Inspiraci√≥n Biol√≥gica

**Retina Humana:**
- **F√≥vea central:** Alta densidad de fotoreceptores (visi√≥n detallada)
- **Periferia:** Baja densidad (visi√≥n perif√©rica)

**Patr√≥n Log-Polar de FREAK:** Imita esta distribuci√≥n

#### Fundamento Matem√°tico

**Patr√≥n de Muestreo:**

```
43 puntos en 7-8 capas conc√©ntricas:
- Capa 0 (centro): 1 punto (œÉ‚ÇÄ)
- Capa 1: 6 puntos (œÉ‚ÇÅ = 2œÉ‚ÇÄ)
- Capa 2: 6 puntos (œÉ‚ÇÇ = 4œÉ‚ÇÄ)
- Capa 3: 6 puntos (œÉ‚ÇÉ = 8œÉ‚ÇÄ)
- ...
- Capa 7: 6 puntos (œÉ‚Çá = 128œÉ‚ÇÄ)

Radio crece exponencialmente: r_i = 2^i ¬∑ r_0
```

**Construcci√≥n del Descriptor:**

**Paso 1: Suavizado Gaussiano por Punto**
$$
S_i = \int\int I(x,y) \cdot G_{\sigma_i}(x - x_i, y - y_i) \, dx \, dy
$$

**Paso 2: Selecci√≥n de Pares (Aprendizaje)**
$$
\text{De 43 puntos} \rightarrow \frac{43 \times 42}{2} = 903 \text{ pares posibles}
$$
$$
\text{Seleccionar 512 mejores usando correlaci√≥n de Pearson}
$$

**Paso 3: Descriptor Binario**
$$
\text{Bit}_k = \begin{cases} 1 & \text{si } S_i > S_j \text{ para par } k=(i,j) \\ 0 & \text{en otro caso} \end{cases}
$$

**Paso 4: Orientaci√≥n Cascada**
$$
\theta = \arctan2\left(\sum_{k} w_k S_k \sin(\phi_k), \sum_{k} w_k S_k \cos(\phi_k)\right)
$$

Donde $w_k$ son pesos aprendidos y $\phi_k$ √°ngulos de los puntos.

#### Caracter√≠sticas Clave

- **Descriptor:** 512 bits (64 bytes)
- **Patr√≥n:** Bio-inspirado, aprendido
- **Matching:** Distancia Hamming (r√°pido)
- **Invarianzas:** Rotaci√≥n ‚úì, Escala ‚úì
- **Velocidad:** ‚ö°‚ö°‚ö°

#### Comparaci√≥n con Otros Binarios

| Aspecto | FREAK | BRIEF | ORB | BRISK | AKAZE |
|---------|-------|-------|-----|-------|-------|
| **Patr√≥n** | Log-polar (43 pts) | Aleatorio | Rotado | Multi-escala | Grid adaptivo |
| **Bits** | 512 | 128-512 | 256 | 512 | 486 |
| **Orientaci√≥n** | ‚úì Cascada | ‚úó | ‚úì Momentos | ‚úì Gradiente | ‚úì Dominante |
| **Aprendizaje** | ‚úì Pares | ‚úó | ‚úó | ‚úó | ‚úó |
| **Velocidad** | ‚ö°‚ö°‚ö° | ‚ö°‚ö°‚ö°‚ö° | ‚ö°‚ö°‚ö°‚ö° | ‚ö°‚ö° | ‚ö°‚ö°‚ö° |
| **Precisi√≥n** | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê |

#### Aplicaciones Espec√≠ficas

- üì∏ **Reconocimiento de se√±ales:** Matching con base de datos
- üé¨ **Tracking temporal:** Seguimiento frame-a-frame
- ü§ñ **SLAM:** Localizaci√≥n y mapeo simult√°neo
- üì± **Apps m√≥viles:** Balance precisi√≥n-eficiencia

---

### 6.2 GrabCut - Segmentaci√≥n Avanzada

#### Fundamento Matem√°tico

**Formulaci√≥n como Optimizaci√≥n de Energ√≠a:**
$$
E(\alpha, k, \theta, z) = U(\alpha, k, \theta, z) + V(\alpha, z)
$$

**Variables:**
- $\alpha \in \{0,1\}^n$: Etiquetas binarias (0=fondo, 1=objeto)
- $k \in \{1,...,K\}^n$: Componente GMM por p√≠xel
- $\theta$: Par√°metros GMM (medias $\mu$, covarianzas $\Sigma$, pesos $\pi$)
- $z$: Observaciones (colores RGB)

#### Modelos de Mezcla Gaussiana (GMM)

**GMM para Objeto:**
$$
p(z|\alpha=1, \theta) = \sum_{k=1}^K \pi_k \cdot \mathcal{N}(z; \mu_k, \Sigma_k)
$$

**GMM para Fondo:**
$$
p(z|\alpha=0, \theta) = \sum_{k=K+1}^{2K} \pi_k \cdot \mathcal{N}(z; \mu_k, \Sigma_k)
$$

**Gaussiana Multivariada (RGB, 3D):**
$$
\mathcal{N}(z; \mu, \Sigma) = \frac{1}{(2\pi)^{3/2}|\Sigma|^{1/2}} \exp\left(-\frac{1}{2}(z-\mu)^T\Sigma^{-1}(z-\mu)\right)
$$

T√≠picamente: $K=5$ componentes para objeto, $K=5$ para fondo.

#### T√©rmino de Datos (Unario)

$$
U(\alpha, k, \theta, z) = \sum_{n=1}^N D(\alpha_n, k_n, \theta, z_n)
$$

$$
D(\alpha_n, k_n, \theta, z_n) = -\log p(z_n | \alpha_n, k_n, \theta) = -\log \pi_{k_n} - \log \mathcal{N}(z_n; \mu_{k_n}, \Sigma_{k_n})
$$

**Interpretaci√≥n:** Penaliza asignaciones de p√≠xeles a modelos improbables.

#### T√©rmino de Suavidad (Pairwise)

$$
V(\alpha, z) = \gamma \sum_{(n,m) \in \mathcal{C}} [\alpha_n \neq \alpha_m] \cdot \frac{1}{\text{dist}(n,m)} \cdot \exp(-\beta||z_n - z_m||^2)
$$

**Par√°metro de contraste:**
$$
\beta = \frac{1}{2 \mathbb{E}[||z_n - z_m||^2]}
$$

**Interpretaci√≥n:**
- Si $||z_n - z_m||$ grande (colores diferentes): Permite borde ($\exp(-\beta \cdot \text{grande}) \approx 0$)
- Si $||z_n - z_m||$ peque√±o (colores similares): Penaliza borde ($\exp(-\beta \cdot \text{peque√±o}) \approx 1$)

#### Algoritmo Iterativo

```
Inicializaci√≥n:
1. Usuario dibuja rect√°ngulo R
2. Œ±_n = {fondo definitivo si n fuera de R
         {probable objeto si n dentro de R
3. Inicializar GMMs con k-means en p√≠xeles conocidos

Iteraci√≥n (hasta convergencia):
  
  ‚îå‚îÄ Paso 1: Asignar Componentes GMM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ Para cada p√≠xel n:                                 ‚îÇ
  ‚îÇ   k_n = argmax_k p(z_n | k, Œ∏_Œ±_n)                ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  
  ‚îå‚îÄ Paso 2: Aprender Par√°metros GMM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ Actualizar {œÄ_k, Œº_k, Œ£_k} usando p√≠xeles         ‚îÇ
  ‚îÇ asignados a cada componente (EM algorithm)         ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  
  ‚îå‚îÄ Paso 3: Estimar Segmentaci√≥n ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ Resolver min-cut en grafo G=(V,E):                ‚îÇ
  ‚îÇ   - V = p√≠xeles + source + sink                   ‚îÇ
  ‚îÇ   - E con capacidades seg√∫n U y V                 ‚îÇ
  ‚îÇ Algoritmo: Max-flow/Min-cut (Boykov-Kolmogorov)   ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  
  Si cambio en Œ± < umbral: CONVERGE
```

#### Graph Cut - Formulaci√≥n

**Grafo G = (V, E):**
- **V√©rtices:** $V = \{\text{p√≠xeles}\} \cup \{\text{source}, \text{sink}\}$
- **Aristas terminales (t-links):**
  - $\text{source} \rightarrow n$: capacidad = $-\log p(z_n|\alpha=1)$
  - $n \rightarrow \text{sink}$: capacidad = $-\log p(z_n|\alpha=0)$
- **Aristas de vecindad (n-links):**
  - $n \leftrightarrow m$: capacidad = $V(\alpha_n, \alpha_m, z_n, z_m)$

**Teorema:** El corte m√≠nimo del grafo equivale a minimizar $E(\alpha, k, \theta, z)$.

#### Ventajas y Limitaciones

**‚úÖ Ventajas:**
- Segmentaci√≥n precisa con m√≠nima interacci√≥n
- Modela distribuci√≥n de color compleja (no solo umbrales)
- Considera contexto espacial (smoothness)
- Iterativo y refinable

**‚ùå Limitaciones:**
- Requiere imagen en **color** (no funciona en escala de grises)
- Sensible a inicializaci√≥n (rect√°ngulo inicial)
- Computacionalmente costoso ($O(n^3)$ en peor caso)
- Asume separaci√≥n clara de colores objeto/fondo

#### Aplicaciones en Tr√°fico

- üöó **Segmentaci√≥n de veh√≠culos:** Extraer veh√≠culo del fondo
- ü™ß **Extracci√≥n de se√±ales:** Aislar se√±al para an√°lisis detallado
- üé® **Dataset preparation:** Generar m√°scaras ground-truth
- üìä **An√°lisis de forma:** Post-segmentaci√≥n para clasificaci√≥n

---

### 6.3 Optical Flow - An√°lisis de Movimiento

#### Fundamento Matem√°tico

**Ecuaci√≥n de Restricci√≥n de Brillo:**

Asunci√≥n: Intensidad de un punto se conserva entre frames.

$$
I(x, y, t) = I(x + dx, y + dy, t + dt)
$$

**Expansi√≥n de Taylor (primer orden):**
$$
I(x+dx, y+dy, t+dt) \approx I(x,y,t) + \frac{\partial I}{\partial x}dx + \frac{\partial I}{\partial y}dy + \frac{\partial I}{\partial t}dt
$$

**Igualando y dividiendo por $dt$:**
$$
I_x \cdot u + I_y \cdot v + I_t = 0
$$

Donde $u = \frac{dx}{dt}$, $v = \frac{dy}{dt}$ son las velocidades del flujo.

**Problema:** 1 ecuaci√≥n, 2 inc√≥gnitas ‚Üí **Aperture Problem** (mal planteado)

#### 6.3.1 Lucas-Kanade (Flujo Disperso)

**Restricci√≥n Adicional:** Flujo constante en vecindad local.

**Sistema sobredeterminado (ventana de $n$ p√≠xeles):**
$$
\begin{bmatrix}
I_x(p_1) & I_y(p_1) \\
I_x(p_2) & I_y(p_2) \\
\vdots & \vdots \\
I_x(p_n) & I_y(p_n)
\end{bmatrix}
\begin{bmatrix} u \\ v \end{bmatrix}
=
-\begin{bmatrix}
I_t(p_1) \\
I_t(p_2) \\
\vdots \\
I_t(p_n)
\end{bmatrix}
$$

**Soluci√≥n por M√≠nimos Cuadrados:**
$$
\begin{bmatrix} u \\ v \end{bmatrix} = 
\left(A^T A\right)^{-1} A^T b
$$

$$
= \begin{bmatrix} 
\sum I_x^2 & \sum I_xI_y \\ 
\sum I_xI_y & \sum I_y^2 
\end{bmatrix}^{-1}
\begin{bmatrix}
-\sum I_xI_t \\
-\sum I_yI_t
\end{bmatrix}
$$

**Condici√≥n de Invertibilidad:**
$$
\det(A^T A) = \left(\sum I_x^2\right)\left(\sum I_y^2\right) - \left(\sum I_xI_y\right)^2 > \text{umbral}
$$

- $\det$ grande ‚Üí Esquina bien definida ‚Üí **Flujo confiable** ‚úÖ
- $\det$ peque√±o ‚Üí Regi√≥n uniforme o borde ‚Üí **Flujo no confiable** ‚ùå

**Pir√°mide Multiescala:**

Para desplazamientos grandes (violaci√≥n de linealizaci√≥n):

```
Nivel 3 (baja res)  ‚Üí  Estimar flujo grueso
        ‚Üì
Nivel 2             ‚Üí  Refinar flujo (warp + estimar)
        ‚Üì
Nivel 1             ‚Üí  Refinar flujo (warp + estimar)
        ‚Üì
Nivel 0 (alta res)  ‚Üí  Flujo final preciso
```

#### 6.3.2 Farneback (Flujo Denso)

**Aproximaci√≥n Polinomial Cuadr√°tica:**
$$
I(x) \approx x^T A x + b^T x + c
$$

Para desplazamiento $d$:
$$
I(x-d) \approx (x-d)^T A (x-d) + b^T (x-d) + c
$$

Expandiendo:
$$
= x^T A x - 2d^T A x + d^T A d + b^T x - b^T d + c
$$

**Igualando con $I_2(x)$ (siguiente frame):**

Asumiendo $A$ constante entre frames:
$$
b_2 = b_1 - 2Ad
$$
$$
d = \frac{1}{2}A^{-1}(b_1 - b_2)
$$

**Estimaci√≥n:**
1. Estimar $A$, $b_1$, $c_1$ en frame 1
2. Estimar $A$, $b_2$, $c_2$ en frame 2
3. Calcular desplazamiento $d$ de los coeficientes

**Par√°metros Clave:**

| Par√°metro | Valor T√≠pico | Efecto |
|-----------|--------------|--------|
| `pyr_scale` | 0.5 | Reducci√≥n entre niveles pir√°mide |
| `levels` | 3-5 | N√∫mero de niveles (m√°s = desplaz. grandes) |
| `winsize` | 15-25 | Ventana promediado (m√°s = smooth) |
| `iterations` | 3 | Iteraciones por nivel |
| `poly_n` | 5-7 | Vecindad para polinomio (impar) |
| `poly_sigma` | 1.1-1.5 | Gaussiana para suavizado coeficientes |

#### M√©tricas Extra√≠das del Flujo

**Por p√≠xel:**
- **Magnitud:** $m(x,y) = \sqrt{u^2 + v^2}$
- **Direcci√≥n:** $\theta(x,y) = \arctan2(v, u) \in [-\pi, \pi]$

**Globales:**
- **Velocidad promedio:** $\bar{m} = \frac{1}{N}\sum m(x,y)$
- **Direcci√≥n dominante:** Pico de histograma circular
- **Coherencia:** Similitud de direcciones locales
  $$\text{coherencia} = 1 - \frac{|\theta(x,y) - \theta_{\text{smoothed}}(x,y)|}{\pi}$$

#### Visualizaci√≥n HSV

**Codificaci√≥n Color:**
- **Hue (Tono):** Direcci√≥n del flujo ($\theta$ ‚Üí [0, 180])
- **Saturation:** 255 (m√°ximo)
- **Value (Brillo):** Magnitud normalizada

```
Para cada p√≠xel (x, y):
  HSV[0] = Œ∏(x,y) * 180/œÄ / 2    # Direcci√≥n ‚Üí Tono
  HSV[1] = 255                    # Saturaci√≥n m√°xima
  HSV[2] = normalize(m(x,y))      # Magnitud ‚Üí Brillo
```

#### Comparaci√≥n Lucas-Kanade vs Farneback

| Aspecto | Lucas-Kanade | Farneback |
|---------|--------------|-----------|
| **Tipo** | Disperso (sparse) | Denso (dense) |
| **Salida** | Vectores en puntos clave | Vector por p√≠xel |
| **Velocidad** | ‚ö°‚ö°‚ö° R√°pido | ‚ö°‚ö° Moderado |
| **Memoria** | Baja (solo keypoints) | Alta (H√óW√ó2 array) |
| **Precisi√≥n** | Alta en puntos | Moderada global |
| **Complejidad** | $O(k \cdot n)$ | $O(H \cdot W \cdot n)$ |
| **Aplicaci√≥n** | Tracking objetos | Flujo global, an√°lisis campo |

#### Aplicaciones en Tr√°fico Vehicular

**1. An√°lisis de Flujo:**
- Velocidad promedio del tr√°fico
- Identificaci√≥n de cuellos de botella
- Patrones de movimiento dominantes

**2. Detecci√≥n de Eventos:**
- Frenadas bruscas ($\Delta m$ grande)
- Cambios de carril (direcci√≥n perpendicular)
- Congesti√≥n (velocidad baja, coherencia alta)

**3. Conteo de Veh√≠culos:**
- Tracking de trayectorias
- Detecci√≥n de cruces de l√≠nea virtual
- Estimaci√≥n de densidad

**4. Seguridad:**
- Movimientos err√°ticos (coherencia baja)
- Detecci√≥n de accidentes (movimiento nulo s√∫bito)
- Validaci√≥n de se√±ales (velocidad compatible)

---

### 6.4 Laplaciano de Gaussiana (LoG)

#### Fundamento Matem√°tico

**Laplaciano:**
$$
\nabla^2 I = \frac{\partial^2 I}{\partial x^2} + \frac{\partial^2 I}{\partial y^2}
$$

**Laplaciano de Gaussiana:**
$$
\nabla^2 G(x,y,\sigma) = -\frac{1}{\pi\sigma^4}\left[1 - \frac{x^2+y^2}{2\sigma^2}\right]\exp\left(-\frac{x^2+y^2}{2\sigma^2}\right)
$$

**Propiedad clave:**
$$
\nabla^2 (G * I) = (\nabla^2 G) * I
$$

Podemos pre-calcular $\nabla^2 G$ como kernel.

#### Detecci√≥n de Blobs

**Principio:** LoG tiene respuesta m√°xima en centro de blob cuando $\sigma$ coincide con tama√±o del blob.

**Algoritmo:**
1. Calcular $\text{LoG}(I, \sigma)$ para m√∫ltiples escalas $\sigma$
2. Detectar extremos en espacio 3D $(x, y, \sigma)$
3. Radio del blob: $r \approx \sqrt{2} \sigma$

#### Aplicaciones

- üî¥ **Detecci√≥n de c√≠rculos:** Sem√°foros, se√±ales circulares
- ‚ö™ **Detecci√≥n de llantas:** Regiones circulares oscuras
- üîç **Preprocesamiento:** Antes de Hough circles

---

## 7. An√°lisis de Texturas

### 7.1 GLCM (Gray-Level Co-occurrence Matrix)

#### Fundamento Matem√°tico

**Definici√≥n:**
$$
P(i, j | d, \theta) = \#\{(x_1,y_1), (x_2,y_2) : I(x_1,y_1)=i, I(x_2,y_2)=j, (x_2-x_1, y_2-y_1)=(d\cos\theta, d\sin\theta)\}
$$

**Normalizaci√≥n:**
$$
P_{\text{norm}}(i,j) = \frac{P(i,j)}{\sum_{i,j} P(i,j)}
$$

#### M√©tricas de Haralick (Selecci√≥n)

**1. Contraste (Variabilidad Local):**
$$
\text{Contraste} = \sum_{i=0}^{N-1} \sum_{j=0}^{N-1} (i-j)^2 \cdot P(i,j)
$$
- Valores altos ‚Üí Bordes fuertes, transiciones abruptas
- Valores bajos ‚Üí Textura suave, uniforme

**2. Energ√≠a/ASM (Uniformidad):**
$$
\text{Energ√≠a} = \sum_{i=0}^{N-1} \sum_{j=0}^{N-1} P(i,j)^2
$$
- Valores altos ‚Üí Textura repetitiva, ordenada
- Valores bajos ‚Üí Textura ca√≥tica, aleatoria

**3. Homogeneidad (Suavidad):**
$$
\text{Homogeneidad} = \sum_{i=0}^{N-1} \sum_{j=0}^{N-1} \frac{P(i,j)}{1 + |i-j|}
$$
- Valores altos ‚Üí Variaciones graduales
- Valores bajos ‚Üí Cambios abruptos

**4. Correlaci√≥n (Dependencia Lineal):**
$$
\text{Correlaci√≥n} = \sum_{i=0}^{N-1} \sum_{j=0}^{N-1} \frac{(i-\mu_i)(j-\mu_j) \cdot P(i,j)}{\sigma_i \cdot \sigma_j}
$$

#### Aplicaciones en Tr√°fico

| Objeto | Contraste | Energ√≠a | Homogeneidad | Interpretaci√≥n |
|--------|-----------|---------|--------------|----------------|
| **Llanta** | Alto | Bajo | Bajo | Patr√≥n radial, textura compleja |
| **Carretera** | Bajo | Alto | Alto | Uniforme, lisa |
| **Se√±al** | Medio | Medio | Medio | Dise√±o estructurado |
| **Vegetaci√≥n** | Medio | Bajo | Medio | Textura irregular |

---

### 7.2 LBP (Local Binary Patterns)

#### Fundamento Matem√°tico

**Definici√≥n para LBP b√°sico:**
$$
\text{LBP}(x_c, y_c) = \sum_{p=0}^{P-1} s(I_p - I_c) \cdot 2^p
$$

Donde:
$$
s(x) = \begin{cases} 1 & \text{si } x \geq 0 \\ 0 & \text{en otro caso} \end{cases}
$$

**LBP Uniforme:** Solo patrones con m√°ximo 2 transiciones 0‚Üí1 o 1‚Üí0

**LBP Invariante a Rotaci√≥n:** Tomar valor m√≠nimo entre todas las rotaciones

#### Ventajas

- ‚ö° Extremadamente r√°pido (solo comparaciones)
- üîÑ Invariante a iluminaci√≥n monot√≥nica
- üì¶ Descriptor compacto (histograma)
- üéØ Captura microestructuras locales

---

## 8. Detecci√≥n de Objetos Espec√≠ficos

### 8.1 Detector de Llantas

#### Estrategia Multi-M√©todo

**M√©todo 1: Hough Circles + Validaci√≥n GLCM**

1. **Transformada de Hough para C√≠rculos:**
   $$
   (x - a)^2 + (y - b)^2 = r^2
   $$
   Espacio de par√°metros 3D: $(a, b, r)$

2. **Filtros geom√©tricos:**
   - Circularidad: $C = \frac{4\pi A}{P^2} \in [0.7, 1.0]$
   - Ratio aspecto: $\frac{W}{H} \in [0.8, 1.2]$
   - Rango radio: $r \in [20, 300]$ px

3. **Validaci√≥n con textura:**
   - Extraer ROI circular
   - Calcular GLCM
   - Validar: Contraste alto, energ√≠a baja (patr√≥n radial)

**M√©todo 2: Contornos + Forma**

1. Umbralizaci√≥n adaptativa
2. Operaciones morfol√≥gicas (apertura)
3. Encontrar contornos
4. Filtrar por circularidad y √°rea

**M√©todo 3: Template Matching**

1. Templates pre-definidos de llantas
2. Multi-escala (0.5√ó a 2√ó)
3. Multi-rotaci√≥n (0¬∞ a 360¬∞ cada 15¬∞)
4. Correlaci√≥n cruzada normalizada

#### Fusi√≥n de Resultados

```
Confianza_final = 0.4¬∑Score_Hough + 0.3¬∑Score_Contorno + 0.3¬∑Score_Template
```

Umbral de aceptaci√≥n: Confianza > 0.6

---

### 8.2 Detector de Se√±ales de Tr√°fico

#### Pipeline

**1. Segmentaci√≥n por Color (Espacio HSV)**

| Color | Rango H | Rango S | Rango V |
|-------|---------|---------|---------|
| Rojo | [0,10] ‚à™ [160,180] | [100,255] | [100,255] |
| Azul | [100,130] | [50,255] | [50,255] |
| Amarillo | [20,40] | [100,255] | [100,255] |

**2. An√°lisis de Forma Geom√©trica**

**Aproximaci√≥n poligonal (Douglas-Peucker):**
$$
\epsilon = k \cdot \text{per√≠metro}
$$

**Clasificaci√≥n:**
- **C√≠rculo:** 3-6 v√©rtices + circularidad > 0.7
- **Tri√°ngulo:** 3 v√©rtices exactos
- **Rect√°ngulo:** 4 v√©rtices + √°ngulos ~90¬∞
- **Oct√°gono:** 7-9 v√©rtices (STOP)

**3. Validaci√≥n Multi-Criterio**
- ‚úÖ √Årea: [500, 50000] px¬≤
- ‚úÖ Forma reconocida
- ‚úÖ Color dominante correcto
- ‚úÖ Ratio relleno > 0.7

---

### 8.3 Detector de Sem√°foros

#### Caracter√≠sticas Estructurales

**1. Detecci√≥n de Caja:**
- Forma rectangular vertical
- Ratio alto/ancho: [2.5, 3.5]
- Color fondo: Negro/gris oscuro

**2. Detecci√≥n de Luces:**

**Por color (HSV):**
- üî¥ Rojo: H‚àà[0,10]‚à™[170,180], S>150, V>150
- üü° Amarillo: H‚àà[20,30], S>150, V>150
- üü¢ Verde: H‚àà[40,80], S>100, V>100

**Por geometr√≠a:**
- C√≠rculos con Hough
- Alineaci√≥n vertical
- Espaciado uniforme

**3. Validaci√≥n de Estado:**
- Solo 1 luz encendida (t√≠pico)
- Posiciones relativas coherentes
- Tama√±o uniforme de luces

---

## 9. Evaluaci√≥n y Comparaci√≥n

### 9.1 Tabla Comparativa Global de Descriptores

| Algoritmo | Keypoints | Descriptor | Velocidad | Precisi√≥n | Invarianzas | Uso Ideal |
|-----------|-----------|------------|-----------|-----------|-------------|-----------|
| **HOG** | N/A (denso) | 3780D flotante | ‚ö°‚ö° | ‚≠ê‚≠ê‚≠ê‚≠ê | Escala parcial | Detecci√≥n objetos, clasificaci√≥n |
| **SIFT** | 500-3000 | 128D flotante | ‚ö° | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Escala, rotaci√≥n, ilum. | Matching preciso, panoramas |
| **SURF** | 300-2000 | 64D flotante | ‚ö°‚ö°‚ö° | ‚≠ê‚≠ê‚≠ê‚≠ê | Escala, rotaci√≥n | Balance velocidad-precisi√≥n |
| **ORB** | 500-1500 | 256b binario | ‚ö°‚ö°‚ö°‚ö° | ‚≠ê‚≠ê‚≠ê | Rotaci√≥n | Tiempo real, embebidos |
| **KAZE** | 400-2500 | 64D flotante | ‚ö°‚ö° | ‚≠ê‚≠ê‚≠ê‚≠ê | Escala, rotaci√≥n | Bordes finos, alta calidad |
| **AKAZE** | 400-2000 | 486b binario | ‚ö°‚ö°‚ö° | ‚≠ê‚≠ê‚≠ê‚≠ê | Escala, rotaci√≥n | Balance completo |
| **FREAK** | 300-1500 | 512b binario | ‚ö°‚ö°‚ö° | ‚≠ê‚≠ê‚≠ê‚≠ê | Rotaci√≥n, escala | Bio-inspirado, eficiente |

### 9.2 Criterios de Selecci√≥n

**Para Tr√°fico Vehicular:**

| Escenario | Algoritmo Recomendado | Justificaci√≥n |
|-----------|----------------------|---------------|
| **Tiempo real (30+ FPS)** | ORB o AKAZE | Velocidad + binario |
| **Alta precisi√≥n** | SIFT o KAZE | Mejor localizaci√≥n |
| **Dispositivo m√≥vil** | ORB o FREAK | Memoria baja |
| **Condiciones adversas** | KAZE o AKAZE | Preserva bordes |
| **Matching robusto** | SIFT o FREAK | Invarianzas m√∫ltiples |
| **Clasificaci√≥n** | HOG + SVM | Descriptor denso |

### 9.3 M√©tricas de Evaluaci√≥n

**Detecci√≥n:**
- **Precisi√≥n:** $P = \frac{TP}{TP + FP}$
- **Recall:** $R = \frac{TP}{TP + FN}$
- **F1-Score:** $F_1 = \frac{2PR}{P+R}$
- **IoU:** $\frac{\text{Intersecci√≥n}}{\text{Uni√≥n}}$

**Descriptores:**
- **N√∫mero de keypoints:** Cobertura
- **Tiempo extracci√≥n:** Eficiencia
- **Ratio matching:** $\frac{\text{Buenos matches}}{\text{Total keypoints}}$
- **Repeatability:** Consistencia bajo transformaciones

---

## 10. Referencias

### 10.1 Papers Fundamentales

1. **HOG:** Dalal & Triggs (2005). *Histograms of oriented gradients for human detection.* CVPR.

2. **SIFT:** Lowe (2004). *Distinctive image features from scale-invariant keypoints.* IJCV.

3. **SURF:** Bay et al. (2008). *Speeded-up robust features.* CVIU.

4. **ORB:** Rublee et al. (2011). *ORB: An efficient alternative to SIFT or SURF.* ICCV.

5. **KAZE:** Alcantarilla et al. (2012). *KAZE features.* ECCV.

6. **AKAZE:** Alcantarilla et al. (2013). *Fast explicit diffusion for accelerated features.* BMVC.

7. **FREAK:** Alahi et al. (2012). *FREAK: Fast retina keypoint.* CVPR.

8. **GrabCut:** Rother et al. (2004). *"GrabCut" - Interactive foreground extraction.* ACM TOG.

9. **Lucas-Kanade:** Lucas & Kanade (1981). *An iterative image registration technique.* IJCAI.

10. **Farneback:** Farneb√§ck (2003). *Two-frame motion estimation based on polynomial expansion.* SCIA.

11. **GLCM:** Haralick et al. (1973). *Textural features for image classification.* IEEE Trans. SMC.

### 10.2 Libros Recomendados

- **Szeliski, R.** (2022). *Computer Vision: Algorithms and Applications* (2nd ed.). [Cobertura completa moderna]

- **Gonzalez & Woods** (2018). *Digital Image Processing* (4th ed.). [Fundamentos s√≥lidos]

- **Prince, S.J.D.** (2012). *Computer Vision: Models, Learning, and Inference*. [Enfoque probabil√≠stico]

### 10.3 Recursos Online

- **OpenCV Docs:** https://docs.opencv.org/
- **PyImageSearch:** https://pyimagesearch.com/
- **Papers with Code:** https://paperswithcode.com/area/computer-vision

---

## Conclusi√≥n

### Resumen de Fortalezas por Categor√≠a

**Descriptores Flotantes (Alta Precisi√≥n):**
- ‚úÖ SIFT: Gold standard, m√°xima robustez
- ‚úÖ SURF: Balance velocidad-precisi√≥n
- ‚úÖ KAZE: Preservaci√≥n de bordes, alta calidad

**Descriptores Binarios (Alta Velocidad):**
- ‚úÖ ORB: M√°s r√°pido, ideal tiempo real
- ‚úÖ AKAZE: Balance completo
- ‚úÖ FREAK: Bio-inspirado, eficiente

**Descriptores Densos (Detecci√≥n):**
- ‚úÖ HOG: Clasificaci√≥n de objetos, SVM

**An√°lisis Temporal:**
- ‚úÖ Optical Flow: Movimiento, velocidad, tracking

**Segmentaci√≥n:**
- ‚úÖ GrabCut: Objeto/fondo con modelos GMM

**Texturas:**
- ‚úÖ GLCM: Caracterizaci√≥n cuantitativa
- ‚úÖ LBP: R√°pido, invariante iluminaci√≥n

### Recomendaci√≥n Final

Para un sistema **robusto** de an√°lisis de tr√°fico vehicular:

1. **Detecci√≥n inicial:** HOG + SVM o YOLO
2. **Tracking:** ORB o AKAZE (velocidad)
3. **Matching preciso:** SIFT o KAZE (precisi√≥n)
4. **An√°lisis temporal:** Optical Flow (Farneback)
5. **Segmentaci√≥n:** GrabCut (cuando necesario)
6. **Validaci√≥n:** GLCM para texturas

**Combinaci√≥n √≥ptima** = M√∫ltiples m√©todos + Fusi√≥n de resultados

---

**Desarrollado para Universidad del Quind√≠o**  
**Visi√≥n Artificial - Octubre 2025**  
**Versi√≥n 5.0 - Documentaci√≥n Optimizada y Enfocada en Caracter√≠sticas**
